# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Normal random numbers, using the Ziggurat method
#' This routine is based on the following article, with a couple of
#' modifications which simplify the implementation.
#'
#'     George Marsaglia, Wai Wan Tsang
#'     The Ziggurat Method for Generating Random Variables
#'     Journal of Statistical Software, vol. 5 (2000), no. 8
#'     http://www.jstatsoft.org/v05/i08/
#'
#' The modifications are:
#'
#' 1) use 128 steps instead of 256 to decrease the amount of static
#' data necessary.  
#'
#' 2) use an acceptance sampling from an exponential wedge
#' exp(-R*(x-R/2)) for the tail of the base strip to simplify the
#' implementation.  The area of exponential wedge is used in
#' calculating 'v' and the coefficients in ziggurat table, so the
#' coefficients differ slightly from those in the Marsaglia and Tsang
#' paper.
#'
#' See also Leong et al, "A Comment on the Implementation of the
#' Ziggurat Method", Journal of Statistical Software, vol 5 (2005), no 7.
#'
#' This function is based on the original GSL version, adapted to
#' use R's system of RNGs. All credits to the original authors.
#' Copyright (C) 2005  Jochen Voss.
#' Copyright (C) 2020  Elias Haddad.
#' License: GPL 3+
#' GSL file: randist/gausszig.c
#' [[Rcpp::export]]
NULL

#' Based on Marsaglia and Tsang, "A Simple Method for
#' generating gamma variables", ACM Transactions on Mathematical
#' Software, Vol 26, No 3 (2000), p363-372.
#' Available at:
#' https://doi.org/10.1145/358407.358414
#' 
#' This function is based on the original GSL version, adapted to
#' use R's system of RNGs. All credits to the original authors.
#' Implemented by J.D.Lamb@btinternet.com, minor modifications for GSL
#' by Brian Gough. Adapted to R by Elias Haddad.
#' Copyright (C) J.D.Lamb, Brian Gough.
NULL

#' License: GPL 3+
#' GSL file: randist/gamma.c
rgamma_mt <- function(n, a, b) {
    .Call(`_Rsubbotools_rgamma_mt`, n, a, b)
}

#' The two-sided exponential probability distribution is  
#' p(x) dx = (1/(2 a)) * exp(-|x/a|) dx
#' for -infty < x < infty. It is also known as the Laplace distribution. 
#' This function is based on the original GSL version, adapted to
#' use R's system of RNGs. All credits to the original authors.
#' randist/laplace.c
#'
#' 
#' Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 James Theiler, Brian Gough
#' Copyright (C) 2020 Elias Haddad 
#' License: GPL 3+
rlaplace <- function(n, m, b) {
    .Call(`_Rsubbotools_rlaplace`, n, m, b)
}

#'  The exponential power probability distribution is  
#'  p(x) dx = (1/(2 a Gamma(1+1/b))) * exp(-|x/a|^b) dx
#'  for -infty < x < infty. For b = 1 it reduces to the Laplace
#'  distribution. 
#'  The exponential power distribution is related to the gamma
#'  distribution by E = a * pow(G(1/b),1/b), where E is an exponential
#'  power variate and G is a gamma variate.
#'  We use this relation for b < 1. For b >=1 we use rejection methods
#'  based on the laplace and gaussian distributions which should be
#'  faster.  For b>4 we revert to the gamma method.
#'  See P. R. Tadikamalla, "Random Sampling from the Exponential Power
#'  Distribution", Journal of the American Statistical Association,
#'  September 1980, Volume 75, Number 371, pages 683-686.
#' 
#'  This function is based on the original GSL version, adapted to
#'  use R's system of RNGs. All credits to the original authors.
#'  GSL file: randist/exppow.c
#'  
#'  Copyright (C) 1996, 1997, 1998, 1999, 2000, 2006, 2007 James Theiler, Brian Gough
#'  Copyright (C) 2006 Giulio Bottazzi 
#'  Copyright (C) 2020 Elias Haddad 
#'  License: GPL 3+
rpower <- function(n, a, b) {
    .Call(`_Rsubbotools_rpower`, n, a, b)
}

#' Produce data distributed according to the power exponential
#'
#' Generate pseudo random-number from a power exponential distribution
#'
#'
#' 
#' @param N number of element
#' @param m the mean 
#' @param a the scale parameter 
#' @param b the exponents 
#' Examples:
#' subbogen -m 1 -b 1 -N 30  sample 30 points from a power exponential with mode
#' in 1, a=1 and b=1 (Laplace)\n");
rsubbo <- function(n = 100L, m = 0.0, a = 1.0, b = 2.0) {
    .Call(`_Rsubbotools_rsubbo`, n, m, a, b)
}

#' Produce data distributed according to Asymmetric Power Exponential
#'
#' 
#' Generate pseudo random-number from an asymmetric power exponential distribution
#'
#'
#' @param N number of element
#' @param m the mean 
#' @param a the scale parameter 
#' @param b the exponents
#' 
#' Examples:\n");
#' subboagen -a 1,2 -N 30  sample 30 points from a asymmetric power exponential   \n");
#' with mode 0, b=2 (Gaussian), al=1 and ar=2;\n");
rasubbo <- function(n = 100L, m = 0.0, bl = 2, br = 2, al = 1, ar = 1) {
    .Call(`_Rsubbotools_rasubbo`, n, m, bl, br, al, ar)
}

alaplafit <- function(data, verb = 0L, method = 7L, output = 0L, provided_m_ = NULL, interv_step = 10L) {
    .Call(`_Rsubbotools_alaplafit`, data, verb, method, output, provided_m_, interv_step)
}

sortRcpp <- function(x) {
    invisible(.Call(`_Rsubbotools_sortRcpp`, x))
}

laplafit <- function(data, verb = 0L, method = 7L, output = 0L, provided_m_ = NULL, interv_step = 10L) {
    .Call(`_Rsubbotools_laplafit`, data, verb, method, output, provided_m_, interv_step)
}

sepfit <- function(data, verb = 0L, method = 7L, interv_step = 10L, output = 0L, provided_m_ = NULL, par = as.numeric( c(0., 1., 0., 2.)), g_opt_par = as.numeric( c(.1, 1e-2, 100, 1e-3, 1e-5, 2,0))) {
    .Call(`_Rsubbotools_sepfit`, data, verb, method, interv_step, output, provided_m_, par, g_opt_par)
}

#' Prints inverse Fisher-Information matrix of AEP
#'
#' Fit skewed power exponential density. 
#' Print inverse Fisher Information matrix of an asymmetric power exponential
#' density with given values for the parameters.
#'
#' @param size numeric - number of observations (Default: 01)
#' @param bl numeric - set the left exponent (Default: 2.0)
#' @param br numeric - set the right exponent (Default: 2.0)
#' @param m  numeric - the location parameter (Default: 0.0)
#' @param al numeric - the left scale parameter (Default: 1.0)
#' @param ar numeric - the right scale parameter (Default: 1.0)
#' @param O_munknown numeric - if true assumes m known
#' @return a list containing three elements:
#'         - std_error - the standard error for the parameters
#'         - infmatrix - the Fisher Information Matrix 
#'         - inv_infmatrix - the Inverse Fisher Information Matrix 
subboafish <- function(size = 1L, bl = 2.0, br = 2.0, m = 0.0, al = 1.0, ar = 1.0, O_munknown = 0L) {
    .Call(`_Rsubbotools_subboafish`, size, bl, br, m, al, ar, O_munknown)
}

subboafit <- function(data, verb = 0L, method = 6L, interv_step = 10L, output = 0L, provided_m_ = NULL, par = as.numeric( c(2., 2., 1., 1., 0.)), g_opt_par = as.numeric( c(.1, 1e-2, 100, 1e-3, 1e-5, 2,0)), itv_opt_par = as.numeric( c(.01, 1e-3, 200, 1e-3, 1e-5, 5,0))) {
    .Call(`_Rsubbotools_subboafit`, data, verb, method, interv_step, output, provided_m_, par, g_opt_par, itv_opt_par)
}

#' Fit a symmetric exponential density
#' 
#' Calculate the standard errors, the correlation, the
#' Fisher Information matrix and its inverse for a power exponential density
#' with given parameters
#'
#' @param size numeric - number of observations (Default: 01)
#' @param b numeric - the exponent b (Default: 2.0)
#' @param m numeric - the location parameter (Default: 0.0)
#' @param a numeric - the scale parameter (Default: 1.0)
#' @param O_munknown numeric - if true assumes m known
#' @return a list containing three elements:
#'         - std_error - the standard error for the parameters
#'         - cor_ab    - the correlation between parameters a and b 
#'         - infmatrix - the Fisher Information Matrix 
#'         - inv_infmatrix - the Inverse Fisher Information Matrix 
#'
#' 
subbofish <- function(size = 1L, b = 2.0, m = 0.0, a = 1.0, O_munknown = 0L) {
    .Call(`_Rsubbotools_subbofish`, size, b, m, a, O_munknown)
}

mm <- function(std_over_aad, verb) {
    .Call(`_Rsubbotools_mm`, std_over_aad, verb)
}

optim_method_moments <- function(data, fmin, provided_m_ = NULL, verb = 0L) {
    .Call(`_Rsubbotools_optim_method_moments`, data, fmin, provided_m_, verb)
}

#' subbofit
#' Fit a power exponential density via maximum likelihood
#'
#'   Verbosity levels:
#'   0 just the final ouput
#'   1 the results of intermediate steps
#'   2 internal information on intermediate steps
#'   3 gory details on intermediate steps
#'
#' Fit symmetric power exponential density. Read from files of from standard input
#' Usage: %s [options] [files]
#' Options:
#'  -O  output type (default 0)
#'       0  parameter b a m and log-likelihood
#'       1  the estimated distribution function computed on the provided points
#'       2  the estimated density function computed on the provided points
#'       3  parameters b a m and their standard errors
#'  -x  set initial conditions b, a,m  (default 2, 1,0)
#'  -m  the mode is not estimated but is set to the value provided
#'  -s  number of intervals to explore at each iteration (default 10)
#'  -V  verbosity level (default 0)
#'       0  just the final result
#'       1  headings and summary table
#'       2  intermediate steps results
#'       3  intermediate steps internals
#'       4+  details of optim. routine
#'  -M  active estimation steps. The value is the sum of (default 7)
#'       1  initial estimation based on method of moments
#'       2  global optimization not considering lack of smoothness in m
#'       4  local optimization taking non-smoothness in m into consideration
#'  -G  set global optimization options. Fields are step, tol, iter, eps, msize, algo.
#'      Empty field implies default (default .1, 1e-2, 100, 1e-3, 1e-5, 3)
#'  -I  set local optimization options. Fields are step, tol, iter, eps, msize, algo.
#'      Empty field implies default (default .01, 1e-4, 200, 1e-4, 1e-5, 5)
#' The optimization parameters are
#'  step  initial step size of the searching algorithm
#'  tol  line search tolerance iter: maximum number of iterations
#'  eps  gradient tolerance : stopping criteria ||gradient||<eps
#'  msize  simplex max size : stopping criteria ||max edge||<msize
#'  algo  optimization methods:
#'          0 Fletcher-Reeves
#'          1 Polak-Ribiere
#'          2 Broyden-Fletcher-Goldfarb-Shanno
#'          3 Steepest descent
#'          4 Nelder-Mead simplex
#'          5 Broyden-Fletcher-Goldfarb-Shanno ver.2
#'
#' Examples:
#'  'subbofit -m 1 -M 6 <file'  estimate a and b with m = 1 and skipping initial
#'                              method of moments estimation
#'
#' methods of estimation
#' 0 - no minimization
#' 1 - method of moments
#' 2 - global optimization
#' 4 - interval optimization
#' interv_step number of intervals to expose
#' interv_step number of intervals to expose
#' par - par[0] = b par[1] = a par[2] = m */
#' itv_opt_par - interval optimization parameters */
subbofit <- function(data, verb = 0L, method = 7L, interv_step = 10L, output = 0L, provided_m_ = NULL, par = as.numeric( c(2.,1.,0.)), g_opt_par = as.numeric( c(.1, 1e-2, 100, 1e-3, 1e-5, 3,0)), itv_opt_par = as.numeric( c(.01, 1e-3, 200, 1e-3, 1e-5, 5,0))) {
    .Call(`_Rsubbotools_subbofit`, data, verb, method, interv_step, output, provided_m_, par, g_opt_par, itv_opt_par)
}

#' short help*/
#' Fit skewed power exponential density. Read from files or from standard input    \n\n");
#' Usage: %s [options] [files]\n\n",argv[0]);
#'  Options:                                                            \n");
#'  -O  output type (default 0)                \n");
#'       0  parameter bl br a m and log-likelihood   \n");
#'       1  the estimated distribution function computed on the provided points     \n");
#'       2  the estimated density function computed on the provided points \n");
#'  -x  set initial conditions bl,br,a,m  (default 2,2,1,1,0)\n");
#'  -m  the mode is not estimated but is set to the value provided\n");
#'  -s  number of intervals to explore at each iteration (default 10)\n");
#'  -V  verbosity level (default 0)           \n");
#'       0  just the final result        \n");
#'       1  intermediate steps results   \n");
#'       2  intermediate steps internals \n");
#'       3+  details of optim. routine   \n");
#'  -M  active estimation steps. The value is the sum of (default 1)\n");
#'       0  no optimization\n");
#'       1  global and local optimization \n");
#'  -G  set global optimization options. Fields are step,tol,iter,eps,msize,algo.\n");
#'      Empty field implies default (default .1,1e-2,100,1e-3,1e-5,2)\n");
#'  -I  set local optimization options. Fields are step,tol,iter,eps,msize,algo.\n");
#'      Empty field implies default (default .01,1e-3,200,1e-3,1e-5,2)\n");
#' The optimization parameters are");
#'  step  initial step size of the searching algorithm                  \n");
#'  tol  line search tolerance iter: maximum number of iterations      \n");
#'  eps  gradient tolerance : stopping criteria ||gradient||<eps       \n");
#'  msize  simplex max size : stopping criteria ||max edge||<msize     \n");
#'  algo  optimization methods: 0 Fletcher-Reeves, 1 Polak-Ribiere,     \n");
#'        2 Broyden-Fletcher-Goldfarb-Shanno, 3 Steepest descent,           \n");
#'        4 Nelder-Mead simplex, 5 Broyden-Fletcher-Goldfarb-Shanno ver.2   \n");
#' Examples:\n");
#'  'subbolafit -m 1 <file'  estimate bl,br,a with m=1\n");
subbolafit <- function(data, verb = 0L, method = 7L, interv_step = 10L, output = 0L, provided_m_ = NULL, par = as.numeric( c(2., 2., 1., 0.)), g_opt_par = as.numeric( c(.1, 1e-2, 100, 1e-3, 1e-5, 3,0)), itv_opt_par = as.numeric( c(.01, 1e-3, 200, 1e-3, 1e-5, 5,0))) {
    .Call(`_Rsubbotools_subbolafit`, data, verb, method, interv_step, output, provided_m_, par, g_opt_par, itv_opt_par)
}

